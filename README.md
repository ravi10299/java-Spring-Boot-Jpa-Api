											
										
											Spring Data JPA( Java Persistance API )
									*********************************************

ODBC  ----> JDBC ---> Hibernate ---> Spring JDBC ---> JPA ---> Spring Data ---> Spring Data JPA

Hibernate : Hibernate is an open-source object-relational mapping (ORM) framework for Java. 
					It provides a powerful and flexible way to map Java objects to database tables and vice versa. 
					Hibernate simplifies the data handling in Java applications by allowing developers to interact 
					with the database using Java objects rather than SQL queries.
Spring JDBC : Spring JDBC is a module within the larger Spring Framework that simplifies database 
				access and error handling in Java applications. 
				It provides a set of abstractions and utilities to interact with relational 
				databases using JDBC (Java Database Connectivity). 
				JDBC is a standard Java API that enables Java applications to interact with databases.

Q. What is JPA?
Java Persistence API is a specification (rules & regulations) that lets you do
Object-Relational Mapping (ORM) over a relational database.

Q. What is ORM?
ORM (Object Relational Mapping)
ORM allows you to map the entity classes to Relational database tables.
class-name ===> Database table name
class-properties ===> Database table columns

Q. What is Spring Data JPA?
 Spring Framework handles ORM concept in an easy and quick fashion using JPA.

**************************************************************************************
Spring data JPA advantages:

1 Spring Data JPA reduces the amount of boilerplate code required for common
database operations.
2 With Spring Data JPA, developers can quickly generate database queries using
method names and query derivation. The framework generates the SQL
queries based on the method names
3 With Spring Data JPA, the developers to switch databases easily without
significant code changes.
4 Spring Data JPA supports multiple query languages, including JPQL (Java
Persistence Query Language) and native SQL.
5 Spring Data JPA provides features that facilitate testing, such as in-memory
databases and test-specific configurations. It allows developers to write unit
tests and integration tests for the data access layer easily.
************************************************************************************

Application-1 Steps to design the application
	Step-1: Create the Entity class.
	Step-2: Give the Database properties in properties file
	Step-3: Create the repository Interface.
	Step-4: Use Repository methods perform the operations.
	Step-5: Start the Spring boot application.

Create the Project,
a. Using Spring initializer
b. In IntellijIdea using spring starter project
Add the Dependencies to this application:
1 spring-boot-starter-web
2 spring-boot-starter-data-jpa
3 Spring-boot-dev-tools
4 MySql Driver 
5 Lombok 

Step-1 : Create the Entity class. 
@Entity
	Specifies that the class is an entity.
	It will create the table in Database,
	java class-name ---> Database table name.
	class properties ---> Database Table columns.

syntax:
	@Entity
	@Data
	@AllArgsConstructor
	@NoArgsConstructor
	@Table(name = "Employee_Info")

	public class Employee {
	@Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private int empId;
    @Column(name = "empName" , length = 30)
    private String name;
    private String emailId;
    private double salary;

}

@Id
Specifies the primary key column of an entity.
syntax:
@Id
private int empId;

@GeneratedValue
Provides Auto generation strategies for the values of primary keys.
The values will be autogenerated.
 syntax:
@GeneratedValue(strategy = GenerationType.AUTO)  
private int empId;
 There are 4-types of Generation,
GenerationType.AUTO
GenerationType.IDENTITY
GenerationType.SEQUENCE
GenerationType.TABLE

@Table
used to specify our own table name.
 syntax:
@Table(name = "emp_info")

public class Employee{
}
@Column
Used to give user defined column name, If we are not given Column
Annotation by default property name taken as column name.
 syntax:
@Column(nullable = false)
@Column(name = "firstEmpname",length = 50)
private String firstName;

Step-2: Give the Database properties in properties file

#Application.properties

#Database Configuration 
spring.datasource.url=jdbc:mysql://localhost:3306/TestDB?createDatabaseIfNotExist=true
spring.datasource.username =root
spring.datasource.password=root
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

#JPA Configuration
#spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL8Dialect
#spring.jpa.database-platform = org.hibernate.dialect.MySQL8Dialect

spring.jpa.hibernate.ddl.auto=update
spring.jpa.generate-ddl=true

spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql= true
server.port=8081

Q. What is Dialect class?
	Dialect class is responsible for generating the appropriate SQL statements
		based on the underlying database system being used.
	H2Dialect ---> Generate H2 database queries.
	OralceDialect---> Generate Oracle database queries.
	MySqlDialect ---> Generate Mysql database queries.

Q. How to show the generated SQL queries?
	spring.jpa.show-sql=true

When you set 
spring.jpa.hibernate.ddl.auto=update, 
Hibernate will automatically update the database schema based on the entity classes defined in your application. 
It means that if there are changes in your entity classes 
(like new fields or changes to existing fields), 
Hibernate will try to reflect those changes in the database schema.

Step-3 : Create the repository Inteface.
@Repository
public interface EmpRepository extends JpaRepository<Emp, Integer> {
}
@Repository:
 Indicates that an annotated class is a "Repository",or a data access object (DAO)
Annotation also serves as a specialization of @Component,
It is applied to classes that perform database operations such as retrieving,
storing, updating, or deleting data.

Step-4: Use Repository methods perform the operations.

@Component
public class BootRunner implements CommandLineRunner {
@Autowired
EmployeeRepository empRepository;
@Override
public void run(String... args) throws Exception {

Employee e1 = new Employee();
e1.setFirstName("Suraj");
e1.setLastName("verma");
e1.setEmail("suraj@gmail");
empRepository.save(e1);

Employee e2 = new Employee();
e2.setFirstName("Rajni");
e2.setLastName("Desai");
e2.setEmail("rdesai@gmail");

Employee e3 = new Employee();
e3.setFirstName("danesh");
e3.setLastName("malli");
e3.setEmail("dilli@gmail.com");
empRepository.saveAll(List.of(e2,e3));

to find the records by using pre defined merhods.
// To Find single record by Id
Emp e = empRepository.findById(1).get();
System.out.println(e);

// To check record exist or not
boolean status1 = empRepository.existsById(3);
System.out.println(status1);

// To Find all of records 
empRepository.findAll().forEach(System.out::println);

// To Find Multiple Records of records 
empRepository.findAllById(List.of(2,3)).forEach(System.out::println);

// To Find count of records 
long count = empRepository.count();
System.out.println(count);


// To delete record by using Id
empRepository.deleteById(3);

// To Delete by using object
empRepository.delete(e3);

// To delete all records
empRepository.deleteAll();

// To delete multiple records by using Id
empRepository.deleteAllById(List.of(3,4));


Step-5: Start the Spring boot application.
@SpringBootApplication
public class SpringBootH2Application {
public static void main(String[] args) {
SpringApplication.run(SpringBootH2Application.class, args);
}
}
Note: When we start the Application The BootRunner class will run automatically. 

Example2:  for Custom query Method

Person.java
@Entity
@Table(name = "person_info")
@Data
@AllArgsConstructor
@NoArgsConstructor
public class Person {
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long id;
private String firstName;
private String lastName;
private String email;
private int age;
}


# PersonRepository.java
@Repository
public interface PersonRepository extends JpaRepository<Person, Long> {

public Person findByEmail(String email);
public List<Person> findAllByFirstName(String firstName);
public List<Person> findAllByLastName(String firstName);
List<Person> findByFirstNameStartingWith(String prefix);
List<Person> findByLastNameEndingWith(String suffix);
public List<Person> findByFirstNameAndLastName(String firstName, String lastName);
public List<Person> findByFirstNameOrLastName(String firstName, String lastName);
List<Person> findByAgeGreaterThan(int age);
List<Person> findByAgeLessThan(int age);

@Transactional void deleteByEmail(String email);
void deleteByLastName(String lastName);
void deleteByFirstNameAndLastName(String firstName, String lastName);


@Component
public class BootRunner implements CommandLineRunner {

@Autowired
PersonRepository personRepository;

@Override
public void run(String... args) throws Exception {
Person p1 = new Person();
p1.setFirstName("Mr.Viren"); 
p1.setLastName("Desai");
p1.setEmail("Viren@gmail.com"); 
p1.setAge(25);

Person p2 = new Person();
p2.setFirstName("Manali"); 
p2.setLastName("Desai");
p2.setEmail("m@gmail.com"); 
p2.setAge(36);

Person p3 = new Person();
p3.setFirstName("saniya"); 
p3.setLastName("naidu");
p3.setEmail("naidu@gmail.com"); 
p3.setAge(66);

Person p4 = new Person();
p4.setFirstName("saniya"); 
p4.setLastName("malli");
p4.setEmail("smali@gmail.com"); 
p4.setAge(76);

personRepository.saveAll(List.of(p1,p2,p3,p4));

Person person = personRepository.findByEmail("naidu@gmail.com");
System.out.println(person);
 personRepository.findByFirstNameStartingWith("n").forEach(System.out::println);
 personRepository.findByLastNameEndingWith("n").forEach(System.out::println);
personRepository.findByFirstName("Viren").forEach(System.out::println);
personRepository.findByLastName("mali").forEach(System.out::println);
personRepository.findByFirstNameAndLastName("Viren", "desai") .forEach(System.out::println);
personRepository.findByFirstNameOrLastName("Saniya", "malli") .forEach(System.out::println);

personRepository.findByAgeGreaterThan(50).forEach(System.out::println);
personRepository.findByAgeLessThan(45).forEach(System.out::println);
personRepository.deleteByEmail("m@gmail.com");
personRepository.deleteByLastName("Manali");
personRepository.deleteByFirstNameAndLastName("Manali", "desai");
}

*********************************************
// Sorting & paging

		personRepository.findAll(Sort.by("firstName").ascending()).forEach(System.out::println);
        personRepository.findAll(Sort.by("lastName").descending()).forEach(System.out::println);

        personRepository.findAll(Sort.by("age").ascending()).forEach(System.out::println);
        personRepository.findAll(Sort.by("emailId").descending()).forEach(System.out::println);

//paging

 personRepository.findAll(PageRequest.of(0, 2)).forEach(System.out::println);

        Page<Person> page = personRepository.findAll(PageRequest.of(1, 2));
        System.out.println("Page number: " + page.getNumber());
        System.out.println("Page size: " + page.getSize());
        System.out.println("Total elements: " + page.getTotalElements());
        page.forEach(System.out::println);

********************************************************************





public interface JpaRepository<T, ID>
extends org.springframework.data.repository.ListCrudRepository<T, ID>,
			 org.springframework.data.repository.ListPagingAndSortingRepository<T, ID>, 
			org.springframework.data.repository.query.QueryByExampleExecutor<T>

public interface ListCrudRepository<T, ID>
extends org.springframework.data.repository.CrudRepository<T, ID>

public interface ListPagingAndSortingRepository<T, ID>
extends org.springframework.data.repository.PagingAndSortingRepository<T, ID>

public interface QueryByExampleExecutor<T>

	CrudRepository							PagingAndSortingRepository				QueryByExampleExecutor
			|														|															|
ListCrudRepository						ListPagingAndSortingRepository						JpaRepository
			|														|
	JpaRepository									JpaRepository












    //    personRepository.deleteByEmailId("smali@gmail.com");
    //    System.out.println(personRepository.count());

    //    personRepository.findByFirstNameStartingWith("s").forEach(System.out::println);

        //personRepository.saveAll(List.of(p1,p2,p3,p4));

//        List<Person> collperson = personRepository.findByFirstName("saniya");
//        collperson.forEach(System.out::println);
//
//        Person p = personRepository.findByEmailId("smali@gmail.com");
//        System.out.println(p);
//
//        System.out.println(personRepository.findByAge(25));
//
//        personRepository.findByFirstName("saniya").forEach(System.out::println);

   //     System.out.println(personRepository.findByFirstNameAndLastName("saniya", "naidu"));

//        personRepository.findAll(Sort.by("firstName").ascending()).forEach(System.out::println);
//        personRepository.findAll(Sort.by("firstName").descending()).forEach(System.out::println);
//
//        personRepository.findAll(Sort.by("age").ascending()).forEach(System.out::println);
//        personRepository.findAll(Sort.by("emailId").descending()).forEach(System.out::println);

    //     personRepository.findAll(PageRequest.of(0, 2)).forEach(System.out::println);

//        Page<Person> page = personRepository.findAll(PageRequest.of(1, 2));
//        System.out.println("Page number: " + page.getNumber());
//        System.out.println("Page size: " + page.getSize());
//        System.out.println("Total elements: " + page.getTotalElements());
//        page.forEach(System.out::println);
